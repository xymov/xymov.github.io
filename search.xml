<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>海洋CMS采集优化</title>
      <link href="/2022/01/15/hai-yang-cms-cai-ji-you-hua.html"/>
      <url>/2022/01/15/hai-yang-cms-cai-ji-you-hua.html</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>现在很多资源站采用苹果CMS构建，特别是官方资源站，海洋CMS采集后可能只有一个视频地址，本文就提供这个解决办法，由nohacks.cn原创，转载请注明出处！</p></blockquote><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>   现在很多资源站采用苹果CMS构建，特别是官方资源，海洋CMS采集后可能只有一个视频地址,没有来源标签或视频标题，这样采集回来的数据是无法在海洋CMS里使用的。</p><p>   笔者经过研究发现唯有修改海洋CMS的源码才能解决，具体步骤如下：</p><p>   打开<code>/include/collection.class.php</code> 在第65行附近找到下面的代码：</p> <pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$flag</span><span class="token operator">=</span><span class="token variable">$z</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"<span class="token interpolation"><span class="token variable">$f</span></span>"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在下面插入下面代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/*  自动修复影片数据   by nohacks.cn */</span><span class="token variable">$dd</span><span class="token operator">=</span><span class="token variable">$video</span><span class="token operator">-&gt;</span><span class="token property">dl</span><span class="token operator">-&gt;</span><span class="token property">dd</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$vod</span><span class="token operator">=</span><span class="token function">explode</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"#"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword type-casting">string</span><span class="token punctuation">)</span><span class="token variable">$dd</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$vlist</span><span class="token operator">=</span><span class="token function">explode</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"$"</span><span class="token punctuation">,</span><span class="token variable">$vod</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token variable">$vlist</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//补充完整</span><span class="token variable">$nohacks</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$vod</span> <span class="token keyword">as</span> <span class="token operator">&amp;</span><span class="token variable">$mov</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token variable">$vlist</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token variable">$mov</span><span class="token operator">=</span><span class="token string double-quoted-string">"正片_"</span><span class="token operator">.</span><span class="token variable">$nohacks</span><span class="token operator">.</span><span class="token string double-quoted-string">"$"</span><span class="token operator">.</span><span class="token variable">$mov</span><span class="token operator">.</span><span class="token string double-quoted-string">"$"</span><span class="token operator">.</span><span class="token variable">$f</span><span class="token punctuation">;</span><span class="token variable">$nohacks</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token variable">$mov</span><span class="token operator">=</span><span class="token variable">$mov</span><span class="token operator">.</span><span class="token string double-quoted-string">"$"</span><span class="token operator">.</span><span class="token variable">$f</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token comment">//重新组合</span><span class="token variable">$video</span><span class="token operator">-&gt;</span><span class="token property">dl</span><span class="token operator">-&gt;</span><span class="token property">dd</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">implode</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"#"</span><span class="token punctuation">,</span><span class="token variable">$vod</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 自动修复影片数据    代码结束    */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存更新缓存即可。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>   这段代码主要是检测影片地址数据,如果发现数据段少于3就开始工作，如果数据段为1，代表只有一个地址，就补充名称和后缀，否则只补充后缀。</p><p>   谢谢观赏，完。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seacms </tag>
            
            <tag> 采集优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站改版</title>
      <link href="/2022/01/10/2022-nian-de-wang-zhan-gai-ban.html"/>
      <url>/2022/01/10/2022-nian-de-wang-zhan-gai-ban.html</url>
      
        <content type="html"><![CDATA[<p>经过几天的折腾，从最开始的blog，到emlog,再到现在用的hexo,感觉还是这个更美观一点，而且是全静态的，文章源码可控，可托管在github上，可靠性也比较高，所以决定以后用这个吧。</p><p>以前的文章会慢慢恢复的,over</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">hexo</span><span class="token expression">的编译发布</span></span>hexo cl <span class="token operator">&amp;&amp;</span> hexo g <span class="token operator">&amp;&amp;</span> hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站改版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网吧影视特权</title>
      <link href="/2022/01/10/netbar-vip-video.html"/>
      <url>/2022/01/10/netbar-vip-video.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>完全免费的网吧影视特权软件，分为服务端和客户端，支持腾讯，优酷，爱奇艺等八家主流视频网站的免VIP视频播放，由nohacks.cn原创，转载请注明出处！</p></blockquote><p><a href="https://imgtu.com/i/7ALGLQ"><img src="https://s4.ax1x.com/2022/01/10/7ALGLQ.jpg"></a></p><p>简介：<br>   早期采用<code>易语言</code>编写的一款免VIP看视频软件，分为服务端和客户端，特别适合<code>网吧</code>使用,最重要的是它完全<code>免费</code>！</p><p>   云端实时更新，支持剧集连播，海量VIP影片等你来看！</p><p>官方地址：<a href="http://user.nohacks.cn/home/article/index/id/1.html" title="点击前往">点击前往</a></p>]]></content>
      
      
      <categories>
          
          <category> 作品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网吧影视特权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联想thinkpad-x1c4 黑苹果经验分享</title>
      <link href="/2022/01/10/thinkpad-x1c4-hackintosh.html"/>
      <url>/2022/01/10/thinkpad-x1c4-hackintosh.html</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p> 本文主要分享了用Thinkpad X1C4 安装最新黑苹果系统时遇到的各种问题以及解决方法，并提供了EFI下载，由nohacks.cn原创，转载请注明出处！</p></blockquote><p><a href="https://imgtu.com/i/7AODht"><img src="https://s4.ax1x.com/2022/01/10/7AODht.png"></a></p><p>   推荐使用<code>黑果小兵</code>的三分区镜像(文末提供下载)，具体安装过程就不讲了，可参考<a href="https://apple.sqlsec.com/" title="国光的黑苹果安装教程">国光的黑苹果安装教程</a>，说下关键的问题：</p><h4 id="出现禁止符"><a href="#出现禁止符" class="headerlink" title="出现禁止符"></a>出现禁止符</h4><p>   默认配置安装会出现禁止符号，需要修改OC配置关闭RTC检测，具体路径<code>kernet-quirks-DisabRtcChecksum</code></p><h4 id="出现动画"><a href="#出现动画" class="headerlink" title="出现动画"></a>出现动画</h4><p>   这个是蓝牙连接助理动画，出现这个是因为键鼠驱动加载失败,这个是需要添加控制驱动，顺序如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">#启用VoodooPS2Controller.kextVoodooPS2Controller.kext/Contents/PlugIns/VoodooPS2Mouse.kextVoodooPS2Controller.kext/Contents/PlugIns/VoodooPS2Keyboard.kextVoodooPS2Controller.kext/Contents/PlugIns/VoodooPS2Trackpad.kext#禁用VoodooPS2Controller.kext/Contents/PlugIns/VoodooInput.kext#然后启用加载基础的 RMI 配置：VoodooRMI.kextVoodooRMI.kext/Contents/PlugIns/VoodooInput.kext#如果你是SMBus触控板的话，还需要加载：VoodooSMBus.kextVoodooRMI.kext/Contents/PlugIns/RMISMBus.kext<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="卡代码或蓝牙WIFI无法使用"><a href="#卡代码或蓝牙WIFI无法使用" class="headerlink" title="卡代码或蓝牙WIFI无法使用"></a>卡代码或蓝牙WIFI无法使用</h4><p>   后来研究发现是蓝牙驱动造成的，需要使用<code>BlueToolFlxup.kext</code>代替原来的<code>interBluetoothlnjector.text</code><br>   WIFI使用最新的<code>Airportltlwm.kext</code>，下载<code>Monterey</code>版本即可。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">#Intel无线和蓝牙加载顺序： AirportItlwm.kext BlueToolFlxup.kext IntelBluetoothFirmware.kext<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="电量及驱动板设置不显示"><a href="#电量及驱动板设置不显示" class="headerlink" title="电量及驱动板设置不显示"></a>电量及驱动板设置不显示</h4><p>   用最新版的<code>ECEnabler.kext</code> 可解决问题</p><p>EFI下载：<a href="https://cloud.189.cn/t/UzYrY3B3qIVf" title="天翼云盘（访问码：7qqc）">天翼云盘（访问码：7qqc）</a><br>参考链接：<a href="https://apple.sqlsec.com/" title="国光的黑苹果安装教程">国光的黑苹果安装教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑苹果 </tag>
            
            <tag> Hackintosh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全聚合影视</title>
      <link href="/2022/01/10/vst-video.html"/>
      <url>/2022/01/10/vst-video.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>vst-video是开源的跨平台资源视频播放器，支持浏览播放自定义资源站视频，堪比快播，由nohacks.cn原创，转载请注明出处！</p></blockquote><p><a href="https://imgtu.com/i/7AO2ng"><img src="https://s4.ax1x.com/2022/01/10/7AO2ng.png"></a></p><p><a href="https://imgtu.com/i/7AOBtI"><img src="https://s4.ax1x.com/2022/01/10/7AOBtI.png"></a></p><p><a href="https://imgtu.com/i/7AOtXD"><img src="https://s4.ax1x.com/2022/01/10/7AOtXD.png"></a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>基于 Qt 的 QMultiMedia组件构建，目标是搭建deepin v20云播放平台。</p><p>主要有以下特色或功能：</p><ul><li>简介高效,快速浏览视频简介，不用频繁在简介和浏览下切换，特别适合现代高分辨率机器。</li><li>自定义资源站，拥有无限视频资源库(百度搜索资源站，使用支持海洋CMS的资源接口)。</li><li>支持主题切换，可选系统，浅色及深色，默认系统。</li><li>兼容古董电脑，可切换渲染模式,可选视频和绘制，现代电脑可选绘制模式以消除绿边，支持更多功能。</li><li>支持本地和远程视频播放，可设置为默认播放器作为本地播放器使用。</li><li>支持播放记录，可快速播放上次播放视频。</li></ul><h3 id="更新历史"><a href="#更新历史" class="headerlink" title="更新历史"></a>更新历史</h3><p>V2.55主要更新<br>添加视频渲染选项，可选视频（默认）和绘制(视频有绿边选择此模式可消除);<br>资源设置添加分类过滤功能；<br>视频播放器右键添加刷新功能;<br>修复自选主题缩放BUG;<br>其它细节优化;</p><h3 id="Windows版本下载"><a href="#Windows版本下载" class="headerlink" title="Windows版本下载"></a>Windows版本下载</h3><p>先安装<a href="https://github.com/Nevcairiel/LAVFilters/releases/download/0.75.1/LAVFilters-0.75.1-Installer.exe" title="解码器">解码器</a>，在下载<a href="https://github.com/xymov/vst-video/releases/download/V2.55/vst-video-win32.zip" title="vst-video-win32.zip">vst-video-win32.zip</a>解压，运行vst-video.exe即可<br>另外默认资源站已经失效，需要更新资源，右上角-菜单-设置-资源设置 ,复制下面的内容进行替换即可。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">天空云,https://api.tiankongapi.com/api.php/provide/vod/at/xml/from/tkm3u8/百度云,https://m3u8.apibdzy.com/api.php/provide/vod/at/xml/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="更多版本下载"><a href="#更多版本下载" class="headerlink" title="更多版本下载"></a><a href="https://github.com/xymov/vst-video/releases/tag/V2.55" title="点击前往">更多版本下载</a></h3>]]></content>
      
      
      <categories>
          
          <category> 作品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快播 </tag>
            
            <tag> 全聚合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xymov智能解析</title>
      <link href="/2022/01/08/xymov.html"/>
      <url>/2022/01/08/xymov.html</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>  xymov视频解析采用缓存技术，能快速响应用户数据请求，体验超清视频急速播放效果，支持80+个视频站点解析内置超强的防火墙、广告过滤功能，保证你每一分钱都不会浪费。轻松实现PC、WAP、APP三端完美对接。</p></blockquote><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4> <iframe id="video" src="https://parse.xymov.net/?url=" scrolling="0" frameborder="0" width="100%" height="500" allowfullscreen="allowfullscreen"></iframe>'<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li><p>云解析：能够主动调用第三方资源站资源播映。</p></li><li><p>API 解析：能够设置调用 苹果 cms/海洋 cms 数据库资源</p></li><li><p>在线查找：用户能够直接在线查找资源播映。</p></li><li><p>广告屏蔽：内置广告屏蔽代码，并配有具体使用说明，轻松屏蔽一次解析广告。</p></li><li><p>授权防盗用功用：可设置域名、ip 授权，做自己的商业解析!</p></li><li><p>在线直播：聚合全网优质在线直播，急速播映，高清画质!能够无限增加!</p></li><li><p>盗用跳转：发现有人盗用你的解析时，主动跳转 你设置的网址</p></li><li><p>缓存功用：之前解析过的视频可进行急速播映无推迟!(可封闭)</p></li><li><p>二次解析线路无限增加!</p></li></ul><p>10.智能解析：能够装备智能解析，能够针对不同来历站主动调用解析!</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>官方网站：<a href="http://www.xymov.net/">http://www.xymov.net</a></p>]]></content>
      
      
      <categories>
          
          <category> 作品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xymov </tag>
            
            <tag> xyplayer </tag>
            
            <tag> 解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编Ring 3下实现 HOOK API</title>
      <link href="/2007/07/18/hui-bian-ring-3-xia-shi-xian-hook-api.html"/>
      <url>/2007/07/18/hui-bian-ring-3-xia-shi-xian-hook-api.html</url>
      
        <content type="html"><![CDATA[<p> 正文：</p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><blockquote><p>很早以前发表在看雪论坛的一篇关于hook api的文章，重新翻出来，以补充博客内容~ 由nohacks.cn原创，转载请注明出处。</p></blockquote><h4 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2. 介绍"></a>2. 介绍</h4><p>  这篇文章是有关在OS Windows下挂钩API函数的方法。所有例子都在基于NT技术的Windows版本NT4.0及以上有效(Windows NT 4.0, Windows 2000, Windows XP，可能在其它Windows系统也会有效。你应该比较熟悉Windows下的进程、汇编器、和一些API函数，才能明白这篇文章里的内容。</p><h5 id="2-1-什么叫Hook-API"><a href="#2-1-什么叫Hook-API" class="headerlink" title="2.1 什么叫Hook API?"></a>2.1 什么叫Hook API?</h5><p>   所谓Hook就是钩子的意思，而API是指Windows开放给程序员的<code>编程接口</code>，使得在用户级别下可以对操作系统进行控制，也就是一般的应用程序都需要调用API来完成某些功能，Hook API的意思就是在这些应用程序调用真正的系统API前可以先被截获，从而进行一些处理再调用真正的API来完成功能。</p><h5 id="2-2-API-Hook的应用介绍"><a href="#2-2-API-Hook的应用介绍" class="headerlink" title="2.2 API Hook的应用介绍"></a>2.2 API Hook的应用介绍</h5><p>   <code>API Hook</code>技术应用广泛,常用于<code>屏幕取词</code>,<code>网络防火墙</code>,<code>病毒木马</code>,<code>加壳软件</code>,<code>串口红外通讯</code>,<code>游戏外挂</code>,<code>internet通信</code>等领域API HOOK的中文意思就是钩住API,对API进行预处理,先执行我们的函数,例如我们用API Hook技术挂接ExitWindowsEx API函数使关机失效,挂接ZwOpenProcess函数隐藏进程等等……</p><h5 id="2-3-API-Hook的原则"><a href="#2-3-API-Hook的原则" class="headerlink" title="2.3 API Hook的原则"></a>2.3 API Hook的原则</h5><p>   HOOK API有一个原则，这个原则就是：被HOOK的API的原有功能不能受到任何影响。就象医生救人,如果把病人身体里的病毒杀死了，病人也死了，那么这个“救人”就没有任何意义了。如果你HOOK API之后，你的目的达到了，但API的原有功能失效了，这样不是HOOK，而是REPLACE，操作系统的正常功能就会受到影响，甚至会崩溃。</p><h4 id="3-挂钩方法"><a href="#3-挂钩方法" class="headerlink" title="3. 挂钩方法"></a>3. 挂钩方法</h4><p>   总的来说,常用的挂钩API方法有以下两种:</p><h5 id="3-1-改写IAT导入表法"><a href="#3-1-改写IAT导入表法" class="headerlink" title="3.1 改写IAT导入表法"></a>3.1 改写IAT导入表法</h5><p>   修改可执行文件的IAT表（即输入表）因为在该表中记录了所有调用API的函数地址，则只需将这些地址改为自己函数的地址即可，但是这样有一个局限，因为有的程序会加壳，这样会隐藏真实的IAT表，从而使该方法失效。</p><h5 id="3-2-改写内存地址JMP法"><a href="#3-2-改写内存地址JMP法" class="headerlink" title="3.2 改写内存地址JMP法"></a>3.2 改写内存地址JMP法</h5><p>   直接跳转，改变API函数的入口或出口的几个字节，使程序跳转到自己的函数,该方法不受程序加壳的限制。这种技术,说起来也不复杂，就是改变程序流程的技术。在CPU的指令里，有几条指令可以改变程序的流程：JMP，CALL，INT，RET，RETF，IRET等指令。理论上只要改变API入口和出口的任何机器码，都可以HOOK,下面我就说说常用的改写API入口点的方法:</p><p>   因为工作在Ring3模式下,我们不能直接修改物理内存,只能一个一个打开修改,但具体的方法又分成好几种,我给大家介绍几种操作思路:</p><p>  &lt;1&gt;首先改写API首字节,要实现原API的功能需要调用API时先还原被修改的字节,然后再调用原API,调用完后再改回来,这样实现有点麻烦,但最简单,从理论上说有漏HOOK的可能,因为我们先还原了API,如果在这之前程序调用了API,就有可能逃过HOOK的可能!</p><p>  (2)把被覆盖的汇编代码保存起来,在替代函数里模拟被被覆盖的功能,然后调用原函数(原地址+被覆盖长度).但这样会产生一个问题,不同的汇编指令长度是不一样的(比如说我们写入的JMP指令占用5个字节,而我们写入的这5个字节占用的位置不一定正好是一个或多个完整的指令,有可能需要保存7个字节,才不能打乱程序原有的功能,需要编写一个庞大的判断体系来判断指令长度,网上已经有这样的汇编程序(Z0MBiE写的LDE32),非常的复杂!</p><p>  (3)把被HOOK的函数备份一下,调用时在替代函数里调用备份函数.为了避免麻烦,可以直接备份整个DLL缺点就是太牺牲内存,一般不推荐使用这种方法!</p><h4 id="4-汇编实现"><a href="#4-汇编实现" class="headerlink" title="4. 汇编实现"></a>4. 汇编实现</h4><p>本文就是建立在第2种方法<code>改写内存地址JMP法</code>之上的!本着先易后难的原则,今天我们先来说说它的第1种操作思路.</p><p>  我们拿API函数ExitWindowsEx来说明,下面是我在OD里拦下的ExitWindowsEx原入口部分</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">77D59E2D            $  8BFF          mov edi,edi  77D59E2F            .  55            push ebp77D59E30            .  8BEC          mov ebp,esp77D59E32            .  83EC 18       sub esp,18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  如果我们把ExitWindowsEx的入口点改为下面的,会出现什么情况?</p><pre class="line-numbers language-none"><code class="language-none">77D59E2D               B8 00400000   mov eax,400077D59E32               FFE0          jmp eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  我们可想而知,程序执行到77D59E32处就会改变流程跳到00400000的地方</p><p>  如果我们的00400000处是这样的子程:</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">=======================MyAPI proc  bs:DWORD  ,dwReserved:DWORD  ;和ExitWindowsEx一样带2个参数                 ;做你想做的事......;这里放API入口点改回原机器码的代码;如果你是备份的整个DLL,就直接调用备份API,不用改来改去了,不会有漏勾API的可能!invoke ExitWindowsEx,bs,dwReserved                           ;这里放HOOK API的代码  .endifmov eax,TRUEret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   这里的MyAPI是和ExitWindowsEx参数一样的的子程,因为程序是在API的入口部分跳转的,根据stdcall约定(参数数据从右向左依次压栈，恢复堆栈的工作交由被调用者),此时堆栈还没有恢复,我们</p><p>在子程里取出的参数数据依然有效,我们可以在这里执行自己的代码,你可以决定是否继续按原参数或改变参数后再调用原API,也可以什么都不做,当然在调用之前,我们要先还原我们修改过的API(可以事先用</p><p>API函数ReadProcessMemory读出原API的前几个字节备份之),调用完后再改回来继续HOOKAPI,不过这种方法有漏API的可能原因前面已经说了),你如果觉得这个方法不妥,因为一般系统DLL都不大,你可以</p><p>备份整个DLL.</p><p>下面我就列出ring3下HOOK API的几个步骤：</p><p>1.得到要挂勾API的入口点</p><p>2.修改API的入口点所在页的页面保护为可读写模式</p><p>3.用ReadProcessMemory读出API的入口点开始的几字节备份</p><p>4.用WriteProcessMemory修改API的入口点象这样的形式:<br>  </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov eax,4000jmp eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br> 其中的4000要用和原API参数一样的子程序地址代替<p></p><p>  在这个子程序里我们决定用什么参数再调用原API,不过调用之前要用备份的前8字节改回来</p><p>调用之后在挂勾,如此反复.</p><h5 id="4-1-代码"><a href="#4-1-代码" class="headerlink" title="4.1. 代码"></a>4.1. 代码</h5><p>  前面所讲的是本进程挂勾,我们要挂勾所有进程,可以用全局勾子,需要单独的一个DLL,我们可以在DLL的DLL_PROCESS_ATTACH事件里来HOOK API</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">=================================hookdll.dll==========================.486 .model flat,stdcall   ;参数的传递约定是stdcall(从右到左，恢复堆栈的工作交由被调用者)option casemap:none include \masm32\include\windows.inc include \masm32\include\kernel32.inc includelib \masm32\lib\kernel32.lib include \masm32\include\user32.inc includelib \masm32\lib\user32.lib HOOKAPI struct a  byte ? PMyapi DWORD ?   d BYTE ?  e BYTE ?HOOKAPI ends;子程序声明WriteApi proto :DWORD ,:DWORD,:DWORD,:DWORDMyAPI proto  :DWORD  ,:DWORDGetApi proto  :DWORD,:DWORD;已初始化数据.data hInstance dd 0WProcess dd 0hacker HOOKAPI &lt;&gt; CommandLine LPSTR ? Papi1 DWORD ? Myapi1 DWORD ?ApiBak1 db 10 dup(?) DllName1  db "user32.dll",0      ApiName1  db "ExitWindowsEx",0 mdb db "下面的程序想关闭计算机,要保持阻止吗?",0;未初始化数据.data? hHook dd ? hWnd dd ? ;程序代码段.code DllEntry proc hInst:HINSTANCE, reason:DWORD, reserved1:DWORD       .if reason==DLL_PROCESS_ATTACH     ;当DLL加载时产生此事件        push hInst         pop hInstance invoke GetCommandLine   mov CommandLine,eax                                         ;取程序命令行;初始化mov hacker.a,0B8h     ;mov eax,;mov hacker.d PMyapi  ;0x000000mov hacker.d,0FFh     ;jmp mov hacker.e, 0E0h    ;eax invoke   GetCurrentProcess                                   ;取进程伪句柄 mov WProcess ,eax    invoke GetApi,addr DllName1,addr ApiName1                    ;取API地址   mov Papi1,eax                                               ;保存API地址invoke ReadProcessMemory,WProcess,Papi1,addr ApiBak1,8,NULL  ;备份原API的前8字节 mov hacker.PMyapi,offset MyAPI   ;0x0000,这里设置替代API的函数地址invoke WriteApi,WProcess,Papi1, addr hacker ,size HOOKAPI    ;HOOK API.endif .if  reason==DLL_PROCESS_DETACH invoke WriteApi,WProcess,Papi1, addr ApiBak1 ,8               ;还原API.endif  mov  eax,TRUE     ret DllEntry Endp GetMsgProc proc nCode:DWORD,wParam:DWORD,lParam:DWORD     invoke CallNextHookEx,hHook,nCode,wParam,lParam      mov eax,TRUE           ret GetMsgProc endp InstallHook proc       invoke SetWindowsHookEx,WH_GETMESSAGE,addr GetMsgProc,hInstance,NULL     mov hHook,eax     ret InstallHook endp UninstallHook proc     invoke UnhookWindowsHookEx,hHook    invoke WriteApi,WProcess,Papi1, addr ApiBak1 ,8  ret UninstallHook endp GetApi proc DllNameAddress:DWORD,ApiNameAddress:DWORDinvoke  GetModuleHandle,DllNameAddress     ;取DLL模块句柄     .if eax==NULL    invoke LoadLibrary ,DllNameAddress    ;加载DLL     .endif   invoke GetProcAddress,eax,ApiNameAddress  ;取API地址   mov eax,eax  retGetApi endp;============================下面是核心部分=========================WriteApi proc Process:DWORD ,Papi:DWORD,Ptype:DWORD,Psize:DWORDLOCAL mbi:MEMORY_BASIC_INFORMATIONLOCAL msize:DWORD;返回页面虚拟信息invoke VirtualQueryEx,Process, Papi,addr mbi,SIZEOF MEMORY_BASIC_INFORMATION;修改为可读写模式invoke VirtualProtectEx,Process, mbi.BaseAddress,8h,PAGE_EXECUTE_READWRITE,addr mbi.Protect;开始写内存invoke  WriteProcessMemory,Process, Papi, Ptype,Psize ,NULLPUSH eax;改回只读模式invoke VirtualProtectEx,Process,mbi.BaseAddress,8h,PAGE_EXECUTE_READ,addr mbi.Protectpop eaxretWriteApi endp;替代的API,参数要和原来一样MyAPI proc  bs:DWORD  ,dwReserved:DWORD                      invoke MessageBox, NULL,  CommandLine, addr mdb, MB_YESNO      ;弹出信息框选择是否阻止.if eax==7                                                   ;如果选择否 invoke WriteApi,WProcess,Papi1, addr ApiBak1 ,8              ;先还原API  invoke ExitWindowsEx,bs,dwReserved                           ;再调用API  invoke WriteApi,WProcess,Papi1, addr hacker ,sizeof HOOKAPI  ;调用完后再改回来  .endifmov eax,TRUE retMyAPI endpEnd DllEntry===============================hookdll.def=============================LIBRARY hookdllEXPORTS InstallHookEXPORTS UninstallHook<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-2-分析"><a href="#4-2-分析" class="headerlink" title="4.2. 分析"></a>4.2. 分析</h5><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">HOOKAPI struct a  byte ? PMyapi DWORD ?   d BYTE ?  e BYTE ?HOOKAPI ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   为了便于理解和使用,我定义了一个结构:这个结构有4个成员,第一个成员a,是个字节型,我用来放0B8h(mov eax),PMyapi一个整数型,用来放我们的替代API函数的地址(0X000),第3个和第4个成员我分别用来放JMP和EAX(jmp eax)那么连起来就是 mov,0X0000 ; jmp eax  </p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm"> .if reason==DLL_PROCESS_ATTACH             push hInst         pop hInstance invoke GetCommandLine   mov CommandLine,eax                                         ;初始化mov hacker.a,0B8h     ;mov eax,;mov hacker.d PMyapi  ;0x0000mov hacker.d,0FFh     ;jmp mov hacker.e, 0E0h    ;eaxinvoke   GetCurrentProcess                                    mov WProcess ,eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  当DLL加载时,我们先保存模块句柄,读取程序命令行,然后初始化HOOKAPI结构,写入我们要写到内存的指令(PMyapi以后写入)并调用GetCurrentProcess取出进程伪句柄方便以后写内存.</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">invoke GetApi,addr DllName1,addr ApiName1                       mov Papi1,eax                                               invoke ReadProcessMemory,WProcess,Papi1,addr ApiBak1,8,NULL   mov hacker.PMyapi,offset MyAPI   ;0x0000   invoke WriteApi,WProcess,Papi1, addr hacker ,size HOOKAPI    ;HOOK API<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  接下来用子程GetApi取出要挂勾API的入口点,并用ReadProcessMemory读出入口点8字节备份之,写入PMyapi调用子程WriteApi改写API的入口点,这个子程我不准备详细说了,它非常的简单,无非就是几个API的调用.它的核心就是通过WriteProcessMemory改写内存.</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">.if  reason==DLL_PROCESS_DETACH invoke WriteApi,WProcess,Papi1, addr ApiBak1 ,8               .endif  mov  eax,TRUE     ret <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   如果这个DLL被卸载了,那么那个在DLL里的替代函数(MyAPI)将是无效的,如果这个时候程序再调用这个API,将出现非法操作,因此在DLL卸载前,我们必须还原API.</p><p>   总结一下,现在只要程序加载这个DLL,这个程序的ExitWindowsEx就会被我们勾住,接下来要怎样才能让所有的程序都加载这个DLL呢?这就需要安装全局勾子:</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">InstallHook proc     invoke SetWindowsHookEx,WH_GETMESSAGE,addr GetMsgProc,hInstance,NULL       invoke WriteApi,WProcess,Papi1, addr hacker ,sizeof HOOKAPI    mov hHook,eax    ret InstallHook endp <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   通过SetWindowsHookEx安装勾子,最后一个参数可以决定该钩子是局部的还是系统范围的。如果该值为NULL，那么该钩子将被解释成系统范围内的，那它就可以监控所有的进程及它们的线程。</p><p>如果该函数调用成功的话，将在eax中返回钩子的句柄，否则返回NULL。我们必须保存该句柄，因为后面我们还要它来卸载钩子,可以看出，我们创建的Hook类型是WH_CALLWNDPROC类型,该类型的Hook在进</p><p>程与系统一通信时就会被加载到进程空间，从而调用dll的初始化函数完成真正的Hook,值得一提的是:因为要调用SetWindowsHookEx来安装钩子,我们GUI程序的这个DLL不会被UnhookWidowHookEx卸载</p><p>,也就只有一次DLL_PROCESS_ATTACH事件,因此这里再要HOOK API一次!</p><p>我们回头来看看钩子回调函数:</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">GetMsgProc proc nCode:DWORD,wParam:DWORD,lParam:DWORD     invoke CallNextHookEx,hHook,nCode,wParam,lParam      mov eax,TRUE        ret GetMsgProc endp <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   可以看到这里只是调用CallNextHookEx将消息交给Hook链中下一个环节处理，因为这里API函数SetWindowsHookEx的唯一作用就是让进程加载我们的dll。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">UninstallHook proc    invoke UnhookWindowsHookEx,hHook    invoke WriteApi,WProcess,Papi1, addr ApiBak1 ,8 ret UninstallHook endp <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要卸载一个钩子时调用UnhookWidowHookEx函数，该函数仅有一个参数，就是欲卸载的钩子的句柄。钩子卸载后我们也要还原我们GUI程序的API.</p><pre class="line-numbers language-none"><code class="language-none">LIBRARY hookdllEXPORTS InstallHookEXPORTS UninstallHook<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>   我们公开DLL里的InstallHook和UninstallHook函数,方便程序调用,这样我们只要在另外的程序中调用InstallHook便可安装全局勾子,勾住所有程序中的API:ExitWindowsEx,执行我们自定的子程!如果不需要了,可以调用UninstallHook卸载全局勾子.</p><p>   请注意：对于远程钩子，钩子函数必须放到DLL中，它们将从DLL中映射到其它的进程空间中去。当WINDOWS映射DLL到其它的进程空间中去时，不会把数据段也进行映射。简言之，所有的进程仅共享DLL的代码，至于数据段，每一个进程都将有其单独的拷贝。这是一个很容易被忽视的问题。您可能想当然的以为，在DLL中保存的值可以在所有映射该DLL的进程之间共享。在通常情况下，由于每一个映射该DLL的进程都有自己的数据段，所以在大多数的情况下您的程序运行得都不错。但是钩子函数却不是如此。对于钩子函数来说，要求DLL的数对所有的进程也必须相同。这样您就必须把数据段设成共享的:</p><p> 一般来说, 目标文件有三个段, 分别是 text/data/bss 段.</p><p>.text 段放置代码, 是只读且可运行段 </p><p>.data 段放置静态数据, 这些数据会被放置入 exe 文件. 这个段是可读写, 但是不能运行的. </p><p>.bss 段放置动态数据, 这些数据不被放入 exe 文件, 在exe文件被加载入内存后才分配的空间.</p><p>你可以通过在链接开关中指定段的属性来实现:</p><p>/SECTION:name,[E][R][W][S][D][K][L][P][X]</p><p>其中S表示共享,已初期化的段名是.data，未初始化的段名是.bss。假如您想要写一个包含钩子函数的DLL，而且想使它的未初始化的数据段在所有进程间共享，您必须这么做：</p><p>link /section:.bss[S]  /DLL  /SUBSYSTEM:WINDOWS ……….</p><p>否则,您的全局勾子将不能正常工作!</p><h4 id="５-结束语"><a href="#５-结束语" class="headerlink" title="５. 结束语"></a>５. 结束语</h4><p>   我欢迎任何人提出更多的这里没有提到的挂钩方法，我肯定那会有很多。同样欢迎补充我介绍得不是很详细的方法。也可以把我懒得写的其它方法完成，把源代码发给我。这篇文档的目的是演示挂钩技术的细节，我希望我做到了。</p><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><p>   看雪原贴：<a href="https://bbs.pediy.com/thread-28895.htm">https://bbs.pediy.com/thread-28895.htm</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 作品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook api </tag>
            
            <tag> asm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
